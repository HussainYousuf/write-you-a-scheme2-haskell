-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module LispVal.Par where
import LispVal.Abs
import LispVal.Lex
import LispVal.ErrM

}

%name pLispVal LispVal
%name pListLispVal ListLispVal
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '\'(' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  'Nil' { PT _ (TS _ 5) }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_LispBool { PT _ (T_LispBool $$) }
L_LispNumber { PT _ (T_LispNumber $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }
LispBool    :: { LispBool} : L_LispBool { LispBool ($1)}
LispNumber    :: { LispNumber} : L_LispNumber { LispNumber ($1)}

LispVal :: { LispVal }
LispVal : Ident { LispVal.Abs.Atom $1 }
        | String { LispVal.Abs.String $1 }
        | LispNumber { LispVal.Abs.Number $1 }
        | LispBool { LispVal.Abs.Bool $1 }
        | 'Nil' { LispVal.Abs.Nil }
        | '(' ListLispVal ')' { LispVal.Abs.SExp $2 }
        | '\'(' ListLispVal ')' { LispVal.Abs.List $2 }
ListLispVal :: { [LispVal] }
ListLispVal : LispVal { (:[]) $1 }
            | LispVal ',' ListLispVal { (:) $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

